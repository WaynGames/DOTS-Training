Partie 2 : Suivi de Chemin
Concepts Introduits
Buffer Dynamique : Un tampon redimensionnable attaché à une entité, utilisé pour stocker une liste de données de longueur variable dans ECS. Les buffers dynamiques permettent de donner à une entité un conteneur semblable à un tableau pour des données liées (par exemple, une série de points de passage) qui peut grandir ou rétrécir à l’exécution.

IBufferElementData : Une interface qui marque un type struct comme un élément dans un buffer dynamique. Chaque élément d’un buffer dynamique doit implémenter IBufferElementData pour être reconnu par ECS. Cela définit la structure de données pour une entrée du tampon (par exemple, une position de point de passage).

Capacité Interne du Tampon : Un attribut qui définit combien d’éléments du tampon sont stockés dans le chunk de l’entité avant que le tampon ne “déborde” vers la mémoire du tas (heap). En ajustant [InternalBufferCapacity], vous pouvez optimiser l’agencement mémoire. La définir à 0 signifie qu’aucun élément n’est stocké dans le chunk, donc tous vont en mémoire tas – utile lorsque la taille de la liste peut être grande ou très variable.

Transformée Locale : Le composant ECS (Unity.Transforms.LocalTransform) qui représente la position, la rotation et l’échelle d’une entité dans l’espace local. Dans Unity ECS 1.0, LocalTransform remplace les composants Translation/Rotation séparés. Il fonctionne conjointement avec LocalToWorld (généré automatiquement avec certains flags de transformation) pour déterminer la position mondiale d’une entité.

Flags d’Utilisation de la Transformée : Une configuration passée à GetEntity dans les bakers pour spécifier les composants de transformation nécessaires à une entité. Par exemple, l’utilisation de TransformUsageFlags.Dynamic garantit que l’entité possède à la fois un LocalTransform (pour le mouvement/la manipulation) et un LocalToWorld (pour le rendu dans le monde) à la création. Ces flags aident le pipeline de conversion à inclure les bons composants de transformation selon le cas d’usage.

Burst : Une technologie de compilation dans Unity DOTS qui optimise le code des jobs et des systèmes pour la performance. En ajoutant la compilation Burst à nos systèmes ECS (ou jobs), on peut considérablement accélérer le code intensif en calculs (comme déplacer de nombreuses entités) et réduire les coûts. Dans la Partie 2, nous utilisons Burst pour compiler la logique de suivi de chemin, ce qui permet une exécution plus rapide et démontre les bénéfices dans le Profiler Unity.

Profiler : L’outil de profilage de Unity permet d’analyser et de mesurer la performance de votre jeu, y compris des systèmes ECS. Dans cette partie, nous utilisons le Profiler pour observer les performances de notre système de suivi de chemin, en particulier pour comparer l’impact de Burst. Nous pouvons placer des marqueurs de profilage (comme Profiler.BeginSample) autour de sections critiques de code ou simplement utiliser la fenêtre du Profiler pour voir les temps de mise à jour des systèmes, vérifiant ainsi que notre système compilé avec Burst s’exécute efficacement.

Dépendance de Conversion : Une manière d’informer le système de conversion (baking) qu’une entité dépend d’un objet ou asset externe. En déclarant une dépendance (avec DependsOn dans un baker), on s’assure que l’entité sera re-convertie si l’asset dépendant change. Dans notre cas, nous indiquons que la conversion de l’entité dépend d’un ScriptableObject (contenant les données de vitesse de déplacement). Si le concepteur modifie la valeur dans le ScriptableObject, le système de baking saura qu’il doit retransformer l’entité pour utiliser les données à jour.

Entité de Conversion Uniquement : Une entité qui n’existe que durant le processus de conversion et qui n’est pas présente à l’exécution. Ceci est typiquement utilisé pour des données temporaires ou intermédiaires que l’on ne souhaite pas conserver à l’exécution. Unity fournit un composant tag BakingOnlyEntity (et un composant d’auteur associé) qui, une fois ajouté, fait que l’entité est supprimée avant d’entrer en mode jeu. Dans ce projet, nous utilisons ce concept pour des entités temporaires ou des GameObjects de conversion uniquement (comme les marqueurs de points de passage) afin qu’ils ne consomment pas de mémoire ou de logique à l’exécution une fois que leurs données ont été intégrées dans d’autres entités.

Modèles de Code Plus Propres : En bonus, cette partie introduit un flux de travail plus propre pour l’écriture et la conversion du code. Nous encapsulons la logique de baking à l’intérieur de la classe MonoBehaviour d’auteur sous forme de classe interne Baker. Cela permet de garder notre code de conversion proche de la définition du composant d’auteur et d’éviter d’encombrer le projet avec de nombreux scripts de baker séparés. C’est un exemple d’organisation du code ECS pour plus de clarté – en utilisant des classes partielles ou imbriquées pour regrouper les fonctionnalités liées.

Analyse du Code
Création du Chemin et Conversion par le Baker
PathFollowAuthoring.cs (MonoBehaviour d’auteur + Baker)
Dans la Partie 2, nous mettons en place un MonoBehaviour PathFollowAuthoring qui contient les données nécessaires pour qu’un ennemi suive un chemin. Ce composant d’auteur possède deux champs importants : une vitesse de déplacement (référencée via un ScriptableObject) et une liste de points de passage (des Transform) définissant le chemin. Lors de la conversion, notre baker lit ces données et ajoute les composants ECS correspondants à l’entité.

La classe PathFollowAuthoring est accompagnée d’une classe interne de baker (EnemyBaker) qui hérite de Baker<PathFollowAuthoring>. Dans la méthode Bake, on obtient une entité pour le GameObject d’auteur et on spécifie qu’elle a besoin de capacités dynamiques de transformation :

Ensuite, nous traitons les points de passage. Nous ajoutons un buffer dynamique de type Waypoints et le remplissons avec la position de chaque point, en les stockant comme éléments du buffer sur l’entité.

La structure Waypoints (voir Waypoints.cs) est définie comme un IBufferElementData.

En définissant [InternalBufferCapacity(0)], on force toutes les données des points de passage à être stockées en mémoire heap, évitant ainsi de gonfler le chunk lorsque les chemins ont de nombreux points.

Après avoir rempli le buffer du chemin, nous ajoutons deux autres composants :

Speed (voir Speed.cs) contient la vitesse de déplacement extraite d’un ScriptableObject. (Ce choix vise à introduire la gestion de dépendances dans le workflow de baking.)

À chaque fois que vous utilisez un ScriptableObject dans le baking, vous devez déclarer qu’il constitue une dépendance :

Cela garantit que l’entité sera re-convertie si le ScriptableObject MovementSpeed change.

Enfin, nous ajoutons NextPathIndex (voir NextPathIndex.cs) pour suivre le point de passage vers lequel l’entité doit se déplacer ensuite, initialisé à 0.

Le Debug.Log($"Baking PathFollower") est simplement là pour indiquer quand le baker est exécuté, afin de montrer la prise en compte de la dépendance avec le ScriptableObject.

Enfin, toutes les entités d’auteur auxiliaires (comme les marqueurs de points de passage) peuvent être marquées comme "baking-only" pour être supprimées à l’exécution, ne laissant que l’entité principale avec son buffer dynamique et les composants nécessaires.

Système de Mouvement : Suivi du Chemin
PathFollowSystem.cs (Système ECS)
Le PathFollowSystem déplace les entités le long de leurs points de passage à l’exécution. Implémenté comme un SystemBase avec Burst :

Dans notre PathFollowSystem, nous utilisons :

RefRO<Speed> – la vitesse ne change pas pendant l’itération, donc une lecture seule est sûre et optimale.

RefRW<LocalTransform> et RefRW<NextPathIndex> – ces deux-là sont modifiés durant le suivi de chemin, un accès en écriture est donc nécessaire.

Cependant, notez que les buffers dynamiques (comme DynamicBuffer<Waypoints>) n’utilisent pas RefRO/RefRW. Cela s’explique par le fait qu’un accès au buffer implique toujours une capacité de lecture/écriture. Unity ne fournit actuellement pas de wrapper en lecture seule pour les buffers dynamiques. Si un accès en lecture seule est nécessaire pour des raisons de sécurité ou de planification des jobs, le développeur doit gérer cela manuellement en utilisant des concepts plus avancés.